<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE cv [
<!ENTITY emdash "&#8212;">
]>

<cv>
  <news-list>
    <news date="2011.07.11" id="summer-workshop">
      <news-snippet>
	Summer workshop July 12.
      </news-snippet>
      <news-detail>
	We will have a workshop with visitors
	<ref table="person" key="swarat" /> (Rice University, USA),
	<ref table="person" key="goubault"/> (CEA, France),
	<ref table="person" key="putot"/> (CEA, France), and
	<ref table="person" key="cesar" /> (IMDEA, Spain)
	in ECOT 832 on July 12 10:00am-6:00pm.
      </news-detail>
    </news>
    <news date="2011.07.07" id="goubault-putot-2011">
      <news-snippet>
	<ref table="person" key="goubault"/> and
	<ref table="person" key="putot"/>
	visit July 11-12.
      </news-snippet>
    </news>
    <news date="2011.07.07" id="chauduri-2011">
      <news-snippet>
	<ref table="person" key="swarat" /> visits July 11-15.
      </news-snippet>
    </news>
    <news date="2011.07.01" id="sanchez-2011">
      <news-snippet>
	<ref table="person" key="cesar" /> visits July 5-August 12.
      </news-snippet>
    </news>
    <news date="2011.06.02" id="ivancic-2011">
      <news-snippet>
	<ref table="person" key="ivancic" /> visits June 4.
      </news-snippet>
    </news>
    <news date="2011.04.25" id="reichenbach-2011">
      <news-snippet>
	<ref table="person" key="creichen"/> visits April 25.
      </news-snippet>
      <news-detail>
	<ref table="person" key="creichen"/> from U of Massachusetts,
	Amherst and alumnus of this group is visiting us on Monday,
	April 25, 2011.  He is giving a talk at 10:00am in ECOT 832.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="creichen"/></speaker>
	<affiliation>University of Massachusetts, Amherst</affiliation>
	<when>04-25-2011 10:00</when>
	<where>ECOT 832</where>
	<title>
	  What can the Garbage Collector compute efficiently? A
	  Language for Heap Assertions at Garbage Collection Time
	</title>
	<abstract>
	  <p>Finding bugs is among the most challenging tasks in
	  software development.  For this reason, modern software
	  development methodologies encourage programmers to use
	  assertions throughout their code to express the assumptions
	  they are making.  At runtime, these assertions then detect
	  whenever the assumptions do not match the program; in other
	  words, they detect bugs early.  However, traditional
	  assertion mechanisms in mainstream languages such as C or
	  Java are limited in their expressivity.</p>
	  <p>This talk presents DeAL, a rich heap assertion language
	  for Java that extends over the expressive power of
	  traditional assertions.  DeAL introduces additional
	  primitives to reason over heap layout, allowing programmers
	  to assert global invariants, ownership, and other properties
	  that would be impossible to express in traditional
	  assertions.</p>
	  <p>By design, all DeAL assertions require only a single heap
	  traversal and can execute as part of garbage collection.
	  Consequently, DeAL is not only expressive, but also ensures
	  a very low execution overhead.</p>
	</abstract>
      </talk-announcement>
    </news>
    <news date="2011.02.22" id="stump-2011">
      <news-snippet>
	<ref table="person" key="astump"/> visits February 24-25.
      </news-snippet>
      <news-detail>
	<ref table="person" key="astump"/> from U of Iowa is visiting
	us February 24-25, 2011.  He is giving a talk on Thursday,
	February 24 at 4:30pm in ECOT 832.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="astump"/></speaker>
	<affiliation>University of Iowa</affiliation>
	<when>02-24-2011 16:30</when>
	<where>ECOT 832</where>
	<title>Building Verified Software with Dependent Types</title>
	<abstract>
	  <p>Recent years have seen intensive interest among
	  Programming Language (PL) researchers in connecting PL and
	  Verification.  Static analyses which once were primarily
	  intended for enabling optimizations in compilers are now
	  used also for program verification and bug finding.  Type
	  systems, which had been used to detect (either statically or
	  dynamically) low-level bugs, are now pushed to express
	  stronger and stronger semantic properties of code.  Arguably
	  the most powerful such systems known are so-called dependent
	  type systems, which combine programming and theorem proving,
	  and use rich types to express general logical specifications
	  of programs.</p>
	  <p>In this talk, I will describe ongoing work in my group to
	  design, prove, and implement dependently typed programming
	  languages, and apply them for challenging case studies.  I
	  will summarize the design of the Guru dependently typed
	  programming language, and explain how it overcomes some
	  traditional difficulties for dependently typed languages,
	  concerning general recursion and also the treatment of
	  equality.  For a case study, I will describe recent work of
	  my doctoral student Duckki Oe to implement a statically
	  verified modern SAT solver called versat in Guru. Versat
	  uses the efficient low-level data structures and algorithms
	  of modern solvers like Minisat, but has been statically
	  verified to be sound: if versat reports "unsat", then the
	  input formula is truly contradictory.  Versat can solve
	  benchmarks on the modern scale, including some from the SAT
	  Competition 2009.  I will conclude with a glimpse at a new
	  dependently typed language called Trellys, being designed
	  and implemented in a collaborative project with Stephanie
	  Weirich at U. Pennsylvania and Tim Sheard at Portland
	  State.</p>
	</abstract>
	<bio>
	  Aaron Stump is an associate professor of Computer Science at
	  The University of Iowa, where he co-leads the U. Iowa
	  Computational Logic Center with Cesare Tinelli.  Aaron
	  received his PhD in Computer Science in 2002 from Stanford
	  University.  His research interests are in Computational
	  Logic and Programming Languages, with current focus on
	  dependently typed programming languages and high-performance
	  proof checking.
	</bio>
      </talk-announcement>
    </news>
    <news date="2011.02.06" id="cook-2011">
      <news-snippet>
	<ref table="person" key="bycook"/> visits February 8.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bycook"/> from MSR Cambridge and Queen
	Mary, University of London is visiting us Tuesday, February 8,
	2011.  He is giving a talk at 3:00pm in ECOT 831.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bycook"/></speaker>
	<affiliation>MSR Cambridge and Queen Mary, University of London</affiliation>
	<when>02-08-2011 15:00</when>
	<where>ECOT 831</where>
	<title>Proving stabilisation of biological models</title>
	<abstract>
	  I will describe an efficient procedure for proving
	  stabilisation of biological systems when modeled as
	  qualitative networks or genetic regulatory networks. For
	  scalability, we use modular proof techniques, where
	  state-space exploration is applied only locally to small
	  pieces of the system rather than the entire system as a
	  whole. Our procedure exploits the observation that, in
	  practice, the form of modular proofs can be restricted to a
	  very limited set.  Using our new procedure, we have solved a
	  number of challenging published examples, including: a 3-D
	  model of the mammalian epidermis; a model of metabolic
	  networks operating in type-2 diabetes; a model of fate
	  determination of vulval precursor cells in the C. elegans
	  worm; and a model of pair-rule regulation during
	  segmentation in the Drosophila embryo. Our results show many
	  orders of magnitude speedup in cases where previous
	  stabilization proving techniques were known to succeed, and
	  new results in cases where tools had previously failed.
	</abstract>
	<bio>
	  Dr. Byron Cook is a principal researcher at Microsoft
	  Research Cambridge, as well as Professor of Computer Science
	  at Queen Mary, University of London.  Byron is one of the
	  developers behind the Terminator program termination prover,
	  as well as the SLAM symbolic software model checker which
	  forms the basis of the Windows Static Driver Verifier tool.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.08.01" id="wang-2010">
      <news-snippet>
	<ref table="person" key="chaowang" /> visits August 26-27.
      </news-snippet>
      <news-detail>
	<ref table="person" key="chaowang" /> from NEC Laboratories
	and CU alumnus is visiting us August 26-27.  He is giving a
	talk in the CS Colloquium on Thursday, August 26 3:30pm-4:30pm
	in ECCR 150.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="chaowang"/></speaker>
	<affiliation>NEC Laboratories</affiliation>
	<when>08-26-2010 15:30</when>
	<where>ECCR 150</where>
	<title>Symbolic Predictive Analysis for Concurrent Programs</title>
	<abstract>
	  <p>Multi-core and multi-processor systems are becoming
	  increasingly popular. However, our ability to effectively
	  harness the power of parallelism is predicated upon advances
	  in tools and algorithms for verifying concurrent
	  programs. Concurrent programs are notoriously difficult to
	  verify, and a key reason for this is the behavioral
	  complexity resulting from the large number of interleavings
	  of concurrent threads.</p>
	  <p>In this talk, I will introduce a symbolic predictive
	  analysis for runtime detection of concurrency errors, by
	  monitoring and subsequently analyzing the execution traces
	  of a program. In this analysis, we first derive a symbolic
	  predictive model using the trace information collected at
	  run time as well as the program source code. What this model
	  captures are not just the given traces, but all possible
	  interleavings of events of these traces. Then we use
	  symbolic reasoning to check whether there are concurrency
	  errors in any of these interleavings. This is done by
	  capturing these interleavings and the error conditions using
	  a set of first-order logic formulas, and then deciding the
	  formulas using an off-the-shelf Satisfiability Modulo Theory
	  (SMT) solver.</p>
	</abstract>
	<bio>
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.07.27" id="rival-2010">
      <news-snippet>
	<ref table="person" key="rival" /> visits August 19-25.
      </news-snippet>
      <news-detail>
	<ref table="person" key="rival"/> from INRIA Roquencourt and
	ENS Paris is visiting us August 19-25.  He is giving a talk on
	the Astrée Static Analyzer on Tuesday, August 24 at 11:00am in
	ECOT 831, and he is also giving a more in-depth demonstration
	of Astrée on Wednesday, August 25 4:00pm-5:00pm in ECST 1B21.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="rival"/></speaker>
	<affiliation>INRIA Roquencourt and ENS Paris</affiliation>
	<when>08-24-2010 11:00</when>
	<where>ECOT 831</where>
	<title>The Astrée Analyzer: Proving the absence of runtime
	errors automatically</title>
	<abstract>
	  <p>Runtime errors in embedded softwares may have disastrous
	  consequences, e.g. in transportation or energy production
	  systems.</p>
	  <p>The Astrée analyzer aims at proving the absence of
	  runtime errors in C programs and was designed specifically
	  for synchronous applications as found in fly-by-wire
	  systems. The analysis process is conservative, that is, it
	  may fail to establish the correctness of some safe programs,
	  but it is sound, that is it will report any runtime error.</p>
	  <p>Astrée performs Abstract Interpretation based static
	  analysis, that is abstract execution, using families of
	  predicates formed by abstract domains. Astrée relies on a
	  library of numerical and symbolic abstract domains, which
	  allow to capture salient properties of embedded softwares,
	  so as to establish absence of runtime errors. The analysis
	  process is fully automatic, and involves automatic
	  parameterization of the abstract domains.</p>
	  <p>We will present the underlying concepts of Astrée, and
	  examplify the use of the analyzer on a few selected
	  examples.</p>
	  <p>The Astrée analyzer has allowed to prove the absence of
	  runtime errors in industrial size avionics programs. As of
	  today, Absint Angewandte Informatik provides commercial
	  diffusion and support of Astrée.</p>
	</abstract>
      </talk-announcement>
    </news>
    <news date="2010.07.27" id="ivancic-2010">
      <news-snippet>
	<ref table="person" key="ivancic" /> visits August 2.
      </news-snippet>
    </news>
    <news date="2010.07.26" id="cook-2010">
      <news-snippet>
	<ref table="person" key="bycook"/> visits July 29.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bycook"/> from MSR Cambridge and
	Queen Mary, University of London is visiting us Thursday, July
	29, 2010.  He is giving a talk in the CS Colloquium at 11:00am
	in ECOT 831.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bycook"/></speaker>
	<affiliation>MSR Cambridge and Queen Mary, University of London</affiliation>
	<when>07-29-2010 11:00</when>
	<where>ECOT 831</where>
	<title>New methods for proving temporal properties of infinite-state systems</title>
	<abstract>
	  I will describe some new methods of proving temporal
	  properties of infinite-state programs.  Our approach takes
	  advantage of the fact that linear-temporal properties can
	  often be proved more efficiently using proof techniques
	  usually associated with the branching-time logic CTL.  The
	  caveat is that, in certain instances, nondeterminism in the
	  system's transition relation can cause CTL methods to report
	  counterexamples that are spurious in LTL. To address this
	  problem we describe an algorithm that, as it attempts to
	  apply CTL proof methods, finds and then removes problematic
	  nondeterminism via an analysis on the spurious
	  counterexamples. We must also develop CTL symbolic model
	  checking tools for infinite-state systems.
	</abstract>
	<bio>
	  Dr. Byron Cook is a Principal Researcher at Microsoft
	  Research in Cambridge, UK as well as Professor of Computer
	  Science at Queen Mary, University of London.  He is one of
	  the developers of the Terminator program termination proving
	  tool, as well as the SLAM software model checker.  Before
	  joining Microsoft Research he was a developer in the WIndows
	  OS kernel group.  See research.microsoft.com/~bycook/ for
	  more information.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.07.05" id="suryanarayanan-2010">
      <news-snippet>
	<ref table="person" key="ssuryana" /> visits July 19.
      </news-snippet>
      <news-detail>
	<ref table="person" key="ssuryana"/> from Colorado School of Mines
	is visiting us on Monday, July 19, 2010.  He is giving a talk in
	the CS Colloquium at 3:00pm in DLC 1B70.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="ssuryana"/></speaker>
	<affiliation>Colorado School of Mines</affiliation>
	<when>07-19-2010 15:00</when>
	<where>DLC 1B70</where>
	<title>Realizing the Smart Grid through smart interfaces, microgrids, and active distribution networks</title>
	<abstract>
	  <p>The electricity infrastructure in the US is poised to
	  undergo unprecedented modernization aided by the "Smart Grid
	  Initiative" for achieving high levels of reliability,
	  efficiency, and interconnection of "green" resources. While
	  the advantages of achieving the Smart Grid Initiative appear
	  bountiful, there are concomitant challenges to realizing
	  this transformation. This talk will describe the present
	  state and future trends of the electricity infrastructure,
	  and the need for Smart Grid legislation. The crux of the
	  seminar will focus on how to realize the Smart Grid
	  Initiative's full impact by innovative research and
	  development on:</p>
	  <ul>
	    <li>Smart interfaces between renewable sources and the
	    electricity grid,</li>
	    <li>Energy efficient electric power microgrids, and</li>
	    <li> Transformation from a passive to active electric
	    distribution network.</li>
	  </ul>
	</abstract>
	<bio>
	  Sid Suryanarayanan is from Chennai, India. He received the
	  Ph.D. in electrical engineering from Arizona State
	  University (ASU) in May 2004. Since January 2008 he has held
	  an Assistant Professor position in the Division of
	  Engineering at Colorado School of Mines (CSM) in Golden,
	  CO. From fall 2010, he will begin an Assistant Professorship
	  in the Dept. of Electrical and Computer Engineering (ECE) at
	  Colorado State University. Prior to that he held research
	  appointments in the faculties of Florida State University
	  and ASU. Sid currently performs sponsored research in the
	  areas of electric power microgrids and the impact of the
	  Smart Grid Initiative on electric power systems.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.03.15" id="pierce-2010">
      <news-snippet>
	<ref table="person" key="bcpierce"/> visits April 29.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bcpierce"/> from UPenn
	is visiting Thursday, April 29, 2010.  He is giving
	a talk in the CS Colloquium at 3:30pm in ECCR 265.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bcpierce"/></speaker>
	<affiliation>University of Pennsylvania</affiliation>
	<when>04-29-2010 15:30</when>
	<where>ECCR 265</where>
	<title>How to Build Your Own Bidirectional Programming Language</title>
	<abstract>
	  <p>Most programs get used in just one direction, from input
	  to output. But sometimes, having computed an output, we need
	  to be able to update this output and then "calculate
	  backwards" to find a correspondingly updated input. The
	  problem of writing such bidirectional transformations --
	  often called lenses -- arises in applications across a
	  multitude of domains and has been attacked from many
	  perspectives. Potential applications include synchronization
	  of replicated data, system configuration management tools
	  (such as RedHat's Augeas system), bidirectional
	  transformations between software models, and updatable
	  "security views."</p>
	  <p>The Harmony project at the University of Pennsylvania is
	  exploring a linguistic approach to bidirectional
	  programming, designing domain-specific languages in which
	  every expression simultaneously describes both parts of a
	  lens. When read from left to right, an expression denotes an
	  ordinary function that maps inputs to outputs. When read
	  from right to left, it denotes an "update translator" that
	  takes an input together with an updated output and produces
	  a new input that reflects the update. These languages share
	  some common elements with modern functional languages -- in
	  particular, they come with very expressive type systems. In
	  other respects, they are rather novel and surprising.</p>
	  <p>We have designed, implemented, and applied bi-directional
	  languages in three quite different domains: a language for
	  bidirectional transformations on trees (such as XML
	  documents), based on a collection of primitive bidirectional
	  tree transformation operations and
	  "bidirectionality-preserving" combining forms; a language
	  for bidirectional views of relational data, using
	  bidirectionalized versions of the operators of relational
	  algebra as primitives; and, most recently, a language for
	  bidirectional string transformations, with primitives based
	  on standard notations for finite-state transduction and a
	  type system based on regular expressions. The string case is
	  especially interesting, both in its own right and because it
	  exposes a number of foundational issues common to all
	  bidirectional programming languages in a simple and familiar
	  setting. We are also exploring how lenses and their types
	  can be enriched to embody privacy and integrity policies.</p>
	  <p>This talk explores the design of bidirectional languages,
	  starting from the very simplest imaginable variant
	  (bijective languages) and then developing several
	  refinements.</p>
	</abstract>
	<bio>
	  Benjamin Pierce joined the CIS Department at Penn in
	  1998. Previously, he was on the faculty at Indiana
	  University and held research fellowships at Cambridge
	  University, the University of Edinburgh, and
	  INRIA-Roquencourt. He received his PhD in Computer Science
	  at Carnegie Mellon University in 1991. His research centers
	  on programming languages, static type systems, concurrent
	  and distributed programming, and synchronization
	  technologies. His books include the widely used graduate
	  text Types and Programming Languages. He is also the lead
	  designer of the popular Unison file synchronizer.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.03.12" id="burtscher-2010">
      <news-snippet>
	<ref table="person" key="burtscher"/> visits March 18.
      </news-snippet>
      <news-detail>
	<ref table="person" key="burtscher"/> from UT Austin and CU
	alumnus is visiting Thursday, March 18, 2010.  He is giving
	a talk in the CS Colloquium at 3:30pm in ECCR 265.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="burtscher"/></speaker>
	<affiliation>The University of Texax at Austin</affiliation>
	<when>03-18-2010 15:30</when>
	<where>ECCR 265</where>
	<title>Towards a Science of Parallel Programming</title>
	<abstract>
	  <p>When parallel programming started in the 70s and 80s, it
	  was mostly art: languages such as functional and logic
	  programming languages were designed and appreciated mainly
	  for their elegance and beauty. More recently, parallel
	  programming has become engineering: conventional languages
	  like FORTRAN and C++ have been extended with constructs such
	  as OpenMP, and we now spend our time benchmarking and
	  tweaking large programs nobody understands to obtain
	  performance improvements of 5-10%. In spite of all this
	  activity, we have few insights into how to write parallel
	  programs to exploit the performance potential of multicore
	  processors.</p>
	  <p>To break this impasse, we need a science of parallel
	  programming. In this talk, I will introduce a concept called
	  "amorphous data-parallelism" that provides a simple, unified
	  picture of parallelism in a host of diverse applications
	  ranging from mesh generation/refinement/partitioning to SAT
	  solvers, maxflow algorithms, stencil computations, and
	  event-driven simulation. Then I will present a natural
	  classification that provides insight into the structure of
	  parallelism and locality in these algorithms and into
	  appropriate language and systems support for exploiting this
	  parallelism.</p>
	</abstract>
	<bio>
	  Martin Burtscher received the combined BS/MS degree in
	  computer science from the Swiss Federal Institute of
	  Technology (ETH) Zurich in 1996 and the PhD degree in
	  computer science from the University of Colorado Boulder in
	  2000. Since then, he has been an assistant professor in the
	  School of Electrical and Computer Engineering at Cornell
	  University and a Research Scientist in the Institute for
	  Computational Engineering and Sciences at the University of
	  Texas at Austin. His current research focuses on automatic
	  parallelization of irregular programs for multicore and GPU
	  architectures as well as on automatic performance assessment
	  and optimization of HPC applications. He is an associate
	  editor of the Journal of Instruction-Level Parallelism and a
	  senior member of the IEEE, its Computer Society, and the
	  ACM.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.02.22" id="chen-2010">
      <news-snippet>
	<ref table="person" key="bradchen"/> visits February 25.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bradchen"/> from Google is visiting
	us Thursday, February 25, 2010.  He is giving a talk in the CS
	Colloquium at 3:30pm in ECCR 265.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bradchen"/></speaker>
	<affiliation>Google</affiliation>
	<when>02-25-2010 15:30</when>
	<where>ECCR 265</where>
	<title>The Desktop: Frontiers in Systems Research</title>
	<host person="diwan"/>
	<abstract>
	  Desktop software, in the form of web browsers, browser
	  features, and OS distributions, are a growing area of
	  engineering activity at Google. This talk will give an
	  overview of this work, looking in detail at Native Client as
	  an example project in the space. Native Client is an
	  open-source research technology for running x86 native code
	  in web applications, with the goal of maintaining the
	  browser neutrality, OS portability, and safety that people
	  expect from web apps. It supports performance-oriented
	  features generally absent from web application programming
	  environments, such as thread support, instruction set
	  extensions such as SSE, and use of compiler intrinsics and
	  hand-coded assembler. We combine these properties in an open
	  architecture designed to leverage existing web standards,
	  and to encourage community review and third-party
	  tools. Overall, Google's desktop efforts seek to enable new
	  Web applications, improve end-user experience, and enable a
	  more flexible balance between client and server
	  computing. Google has open sourced many of our desktop
	  efforts, in part to encourage collaboration and independent
	  innovation.
	</abstract>
	<bio>
	  J. Bradley Chen manages the Native Client project at Google,
	  where he has also worked on cluster performance analysis
	  projects. Prior to joining Google, he was Director of the
	  Performance Tools Lab in Intel's Software Products
	  Division. Chen served on the faculty of Harvard University
	  from 1994-1998, conducting research in operating systems,
	  computer architecture and distributed system, and teaching a
	  variety of related graduate and undergraduate courses. He
	  has published widely on the subjects of systems performance
	  and computer architecture. Dr. Chen has bachelors and
	  masters degrees from Stanford University and a PhD from
	  Carnegie Mellon University.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.01.13" id="strout-2010">
      <news-snippet>
	<ref table="person" key="mstrout"/> visits January 28.
      </news-snippet>
      <news-detail>
	<ref table="person" key="mstrout"/> from Colorado State is
	visiting us Thursday, January 28, 2010.  She is giving a talk
	in the CS Colloquium at 3:30pm in ECCR 265.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="mstrout"/></speaker>
	<affiliation>Colorado State University</affiliation>
	<when>01-28-2010 15:30</when>
	<where>ECCR 265</where>
	<title>Introducing the Sparse Polyhedral Framework</title>
	<abstract>
	  <p>Loops often dominate the execution time of
	  applications. Various transformation frameworks have been
	  developed to enable the automatic compile-time
	  transformation of loops. Many of the existing models fit
	  within the polyhedral framework and although they are quite
	  powerful, they are restricted to compile-time
	  transformations and loop bounds and memory accesses that are
	  affine or can be approximated as affine.</p>
	  <p>In this talk, I will present the Sparse Polyhedral
	  Framework (SPF). The SPF builds on the polyhedral
	  programming model, but is also capable of expressing and
	  supporting the code generation for run-time reordering
	  transformations implemented with inspector/executor
	  strategies. I will then discuss the idea of abstractions for
	  exposing transformation frameworks in performance programmer
	  models.</p>
	</abstract>
	<bio>
	  Michelle Mills Strout is an assistant professor of computer
	  science at Colorado State University. She obtained her PhD
	  in Computer Science from the University of California, San
	  Diego in June 2003. In 2008, Michelle received a CAREER
	  Award from the National Science Foundation for her research
	  in parallelization techniques for irregular applications,
	  such as molecular dynamics simulations. Her main research
	  area is high performance computing and her research
	  interests include compilers and run-time systems, scientific
	  computing, and software engineering.
	</bio>
      </talk-announcement>
    </news>
    <news date="2010.01.06" id="bodik-2010">
      <news-snippet>
	<ref table="person" key="bodik"/> visits January 11.
      </news-snippet>
      <news-detail>
	<ref table="person" key="bodik"/> from UC Berkeley is visiting
	us Tuesday, January 11, 2011.  He is giving a talk at 3:00pm
	in DLC 1B70.
      </news-detail>
      <talk-announcement>
	<speaker><ref table="person" key="bodik"/></speaker>
	<affiliation>University of California Berkeley</affiliation>
	<when>01-11-2010 15:00</when>
	<where>DLC 1B70</where>
	<title>Algorithmic Program Synthesis with Partial Programs</title>
	<abstract>
	  <p>Why hasn't Moore's Law revolutionize programming?  In
	  model checking, cycles fuel bug discovery, improving code
	  quality, but programmers still write programs with their
	  bare hands.  In fact, their work has not changed much since
	  the CRT terminal, except that they think in better
	  languages.</p>
	  <p>Program synthesis might be a way to reduce
	  the programmer's cognitive load.  Synthesizers have derived
	  programs that were highly efficient, and sometimes even
	  surprising.  Of course, they had to be first "programmed"
	  with the human insights about the domain at hand.</p>
	  <p>Which brings us to a key problem in program synthesis ---
	  how to communicate human expertise to the synthesizer.  In
	  deductive synthesis, this expertise is captured in a domain
	  theory.  Often elusive even to formally trained experts, a
	  domain theory is probably not a shortcut to programmer
	  productivity.</p> <p>This talk will describe a growing
	  family of synthesizers based on partial programs.  Their
	  premise is that programs can be decomposed into insight and
	  mechanics: if the programmer encodes her insight as a
	  partial program, the mechanics can then be synthesized given
	  a specification.  Partial programs lend themselves to
	  algorithmic synthesis: rather than deducing a program with a
	  theorem prover, algorithmic synthesis finds the program in a
	  space of candidate implementations described by the partial
	  program.</p>
	  <p>Among five synthesizers, I will describe an algorithm for
	  finding a candidate by constraint solving, rather than via
	  generate-and-test, and a system for programming with angelic
	  non-determinism which computes the insight into a
	  programming problem.</p>
	</abstract>
	<bio>
	  Ras Bodik is an Associate Professor of Computer Science at
	  UC Berkeley.  He is interested in programming systems, from
	  static and dynamic analysis to programmer tools.  He leads a
	  project of program synthesis for high-performance programs
	  based on the idea of program sketches.  He also leads a
	  project on parallel web browsers for mobile devices, which
	  develops parallel parsing and page layout algorithms, as
	  well as a constraints-based scripting language.
	</bio>
      </talk-announcement>
    </news>
    <news date="2009.06.05" id="birkedal-2009">
      <news-snippet>
	<ref table="person" key="birkedal" /> visits July 3.
      </news-snippet>
    </news>
    <news date="2009.03.04" id="pfenning-2009">
      <news-snippet>
	<ref table="person" key="fp" /> visits March 6.
      </news-snippet>
    </news>
  </news-list>

  <projects>
  </projects>

  <publications>
    <pub id="ptaprecision-sas11">
      <title>The Flow-Insensitive Precision of Andersen's Analysis in Practice</title>
      <authors>
	<author person="blackshear" />
	<author person="bec" />
	<author person="srirams" />
	<author person="msridhar" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/sas11-ptaprecision.pdf</url>
      </urls>
      <howpub>
	<proceedings event="sas11" />
      </howpub>
      <abstract>
	<p>We present techniques for determining the precision gap
	between Andersen's points-to analysis and precise
	flow-insensitive points-to analysis in practice.  While
	previous work has shown that such a gap may exist, no
	efficient algorithm for precise flow-insensitive analysis is
	known, making measurement of the gap on real-world programs
	difficult.  We give an algorithm for precise flow-insensitive
	analysis of programs with finite memory, based on a novel
	technique for refining any points-to analysis with a search
	for flow-insensitive witnesses.  We give a compact symbolic
	encoding of the technique that enables computing the search
	using a tuned SAT solver.  We also present extensions of the
	algorithm that enable computing lower and upper bounds on the
	precision gap in the presence of dynamic memory allocation. In
	our experimental evaluation over a suite of small- to
	medium-sized C programs, we never observed a precision gap
	between Andersen's analysis and the precise analysis. In other
	words, Andersen's analysis computed a precise flow-insensitive
	result for all of our benchmarks.  Hence, we conclude that
	while better algorithms for the precise flow-insensitive
	analysis are still of theoretical interest, their practical
	impact for C programs is likely to be negligible.</p>
      </abstract>
    </pub>
    <pub id="relationalization-cav11">
      <title>Relational Abstractions for Continuous and Hybrid Systems</title>
      <authors>
	<author person="srirams" />
	<author person="atiwari"/>
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~srirams/papers/cav11-relational.pdf</url>
      </urls>
      <howpub> <proceedings event="cav11" /> </howpub>
      <abstract> 
  <p> In this paper, we define relational abstractions of hybrid systems.
  A relational abstraction is obtained by replacing the continuous
  dynamics in each mode by a binary transition relation that relates a
  state of the system to any state that can potentially be reached at
  some future time instant using the continuous dynamics.  We
  construct relational abstractions by reusing template-based
  invariant generation techniques for continuous systems described by
  Ordinary Differential Equations (ODE).  As a result, we abstract a
  given hybrid system as a purely discrete, infinite-state system.  We
  apply k-induction to this abstraction to prove safety properties,
  and use bounded model-checking to find potential falsifications.  We
  present the basic underpinnings of our approach and demonstrate its
  use on many benchmark systems to derive simple and usable
  abstractions. </p>
      </abstract>
    </pub>
    <pub id="linearization-hscc11">
        <title> Automatic Abstraction of Non-Linear Systems Using Change of Variables Transformations </title> 
    <authors>
    <author person="srirams"/>
    </authors>
    <urls> <url name="pdf"> http://www.cs.colorado.edu/~srirams/papers/hscc11.pdf</url>
    </urls>
    <howpub> 
    <proceedings event="hscc11"/>
    </howpub>
    <abstract>
 <p>      We present abstraction techniques that transform a given non-linear
  dynamical system into a linear system, such that, invariant
  properties of the resulting linear abstraction can be used to infer
  invariants for the original system. The abstraction techniques rely
  on a change of bases transformation that associates each state
  variable of the abstract system with a function involving the state
  variables of the original system. We present conditions under which
  a given change of basis transformation for a non-linear system can
  define an abstraction. </p>
  
<p>  Furthermore, we present a technique to discover, given a non-linear
  system, if a change of bases transformation involving degree-bounded
  polynomials yielding a linear system abstraction exists. If so, our
  technique yields the resulting abstract linear system, as well. This
  approach is further extended to search for a change of bases
  transformation that abstracts a given non-linear system into a
  system of linear differential inclusions.  Our techniques enable the
  use of analysis techniques for linear systems to infer invariants
  for non-linear systems. We present preliminary evidence of the
  practical feasibility of our ideas using a prototype implementation. </p>
    </abstract>
    </pub>
    <pub id="staliro-tool-paper">
      <title>S-Taliro: A Tool for Temporal Logic Falsification for Hybrid Systems</title>
      <authors>
	<author person="yeshwanta"/>
	<author person="liuche"/>
	<author person="fainekosg"/>
	<author person="srirams"/>
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~srirams/papers/sTaliro-tacas11.pdf</url>
      </urls>
      <howpub> 
	<proceedings event="tacas11"/>
      </howpub>
      <abstract>
<p>S-TaLiRo is a Matlab (TM) toolbox that searches for trajectories of
minimal robustness in Simulink/Stateflow diagrams. It can analyze
arbitrary Simulink models or user defined functions that model the
system. At the heart of the tool, we use randomized testing based on
stochastic optimization techniques including Monte-Carlo methods and
Ant-Colony Optimization. Among the advantages of the toolbox is the
seamless integration inside the Matlab environment, which is widely
used in the industry for model-based development of control
software. We present the architecture of S-TaLiRo and its working on
an application example.</p>
    </abstract>
    </pub>

    <pub id="template-esop11">
    <title> Generalizing the Template Polyhedral Domain </title>
    <authors>
    <author person="colonm"/>
    <author person="srirams"/>
    </authors>
    <urls>
      <url name="pdf">http://www.cs.colorado.edu/~srirams/papers/gtp-esop10.pdf</url>
    </urls>
    <howpub> 
    <proceedings event="esop11"/>
    </howpub>
    <abstract>
  <p>Template polyhedra generalize weakly relational domains by
  specifying arbitrary fixed linear expressions on the left-hand sides
  of inequalities and undetermined constants on the right. The domain
  operations required for analysis over template polyhedra can be
  computed in polynomial time using linear programming.  In this
  paper, we introduce the generalized template polyhedral domain that
  extends template polyhedra using fixed left-hand side expressions
  with bilinear forms involving program variables and unknown
  parameters to the right. We prove that the domain operations over
  generalized templates can be defined as the ``best possible
  abstractions'' of the corresponding polyhedral domain
  operations. The resulting analysis can straddle the entire space of
  linear relation analysis starting from the template domain to the
  full polyhedral domain.</p>


<p>  We show that analysis in the generalized template domain can be
  performed by dualizing the join, post-condition and widening
  operations.  We also investigate the special case of template
  polyhedra wherein each bilinear form has at most two parameters. For
  this domain, we use the special properties of two dimensional
  polyhedra and techniques from fractional linear programming to
  derive domain operations that can be implemented in polynomial time
  over the number of variables in the program and the size of the
  polyhedra. We present applications of generalized template polyhedra
  to strengthen previously obtained invariants by converting them into
  templates.  We describe an experimental evaluation of an
  implementation over several benchmark systems.</p>
    </abstract>
    </pub>
    <pub id="blame-popl11">
      <title>Blame for All</title>
      <authors>
	<author person="amal" />
	<author person="robby" />
	<author person="siek" />
	<author person="wadler" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/blame-forall-2011.pdf</url>
      </urls>
      <howpub>
	<proceedings event="popl11" />
      </howpub>
      <abstract>
	<p>Several programming languages are beginning to integrate
	static and dynamic typing, including Racket (formerly PLT
	Scheme), Perl 6, and C# 4.0 and the research languages Sage
	(Gronski, Knowles, Tomb, Freund, and Flanagan, 2006) and Thorn
	(Wrigstad, Eugster, Field, Nystrom, and Vitek, 2009). However,
	an important open question remains, which is how to add
	parametric polymorphism to languages that combine static and
	dynamic typing. We present a system that permits a value of
	dynamic type to be cast to a polymorphic type and vice versa,
	with relational parametricity enforced by a kind of dynamic
	sealing along the lines proposed by Matthews and Ahmed (2008)
	and Neis, Dreyer, and Rossberg (2009). Our system includes a
	notion of blame, which allows us to show that when casting
	between a more-precise type and a less-precise type, any cast
	failures are due to the less-precisely-typed portion of the
	program. We also show that a cast from a subtype to its
	supertype cannot fail.</p>
      </abstract>
    </pub>
    <pub id="stack-popl11">
      <title>Calling Context Abstraction with Shapes</title>
      <authors>
	<author person="rival" />
	<author person="bec" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/popl11-stack.pdf</url>
	<url name="ps">http://www.cs.colorado.edu/~bec/papers/popl11-stack.ps</url>
      </urls>
      <howpub>
	<proceedings event="popl11" />
      </howpub>
      <abstract>
	<p>Interprocedural program analysis is often performed by
	computing procedure summaries.  While possible, computing
	adequate summaries is difficult, particularly in the presence
	of recursive procedures.  In this paper, we propose a
	complementary framework for interprocedural analysis based on
	a direct abstraction of the calling context.  Specifically,
	our approach exploits the inductive structure of a calling
	context by treating it directly as a stack of activation
	records.  We then build an abstraction based on separation
	logic with inductive definitions.  A key element of this
	abstract domain is the use of parameters to refine the meaning
	of such call stack summaries and thus express relations across
	activation records and with the heap.  In essence, we define
	an abstract interpretation-based analysis framework for
	recursive programs that permits a fluid per call site
	abstraction of the call stack&emdash;much like how shape analyzers
	enable a fluid per program point abstraction of the heap.</p>
      </abstract>
    </pub>
    <pub id="accessnets-vmcai11">
      <title>Access Nets: Modeling Access to Physical Spaces</title>
      <authors>
	<author person="frohardt" />
	<author person="bec" />
	<author person="srirams" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/accessnets-vmcai11.pdf</url>
	<url name="ps">http://www.cs.colorado.edu/~bec/papers/accessnets-vmcai11.ps</url>
      </urls>
      <howpub>
	<proceedings event="vmcai11" />
      </howpub>
      <note>
	<tr>
	  <extendedtr />
	  <number>CU-CS-1076-10</number>
	  <url>http://www.cs.colorado.edu/~bec/papers/CU-CS-1076-10.pdf</url>
	</tr>
      </note>
      <abstract>
	<p>Electronic, software-managed mechanisms using, for example,
	radio-frequency identification (RFID) cards, enable great
	flexibility in specifying access control policies to physical
	spaces.  For example, access rights may vary based on time of
	day or could differ in normal versus emergency situations.
	With such fine-grained control, understanding and reasoning
	about what a policy permits becomes surprisingly difficult
	requiring knowledge of permission levels, spatial layout, and
	time.  In this paper, we present a formal modeling framework,
	called <fmt kind="tool">Access Nets</fmt>, suitable for describing a
	combination of access permissions, physical spaces, and
	temporal constraints.  Furthermore, we provide evidence that
	model checking techniques are effective in reasoning about
	physical access control policies.  We describe our results
	from a tool that uses reachability analysis to validate
	security policies.</p>
      </abstract>
    </pub>
    <pub id="mix-pldi10">
      <title>Mixing Type Checking and Symbolic Execution</title>
      <authors>
	<author person="khooyp" />
	<author person="bec" />
	<author person="jfoster" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/pldi10-mix.pdf</url>
	<url name="ps">http://www.cs.colorado.edu/~bec/papers/pldi10-mix.ps</url>
      </urls>
      <howpub>
	<proceedings event="pldi10" />
      </howpub>
      <note>
	<tr>
	  <extendedtr />
	  <number>CS-TR-4954</number>
	  <url>http://hdl.handle.net/1903/10115</url>
	</tr>
      </note>
      <abstract>
	<p>Static analysis designers must carefully balance precision
	and efficiency.  In our experience, many static analysis tools
	are built around an elegant, core algorithm, but that
	algorithm is then extensively tweaked to add just enough
	precision for the coding idioms seen in practice, without
	sacrificing too much efficiency.  There are several downsides
	to adding precision in this way: the tool's implementation
	becomes much more complicated; it can be hard for an end-user
	to interpret the tool's results; and as software systems vary
	tremendously in their coding styles, it may require
	significant algorithmic engineering to enhance a tool to
	perform well in a particular software domain.</p>
	<p>In this paper, we present Mix, a novel system that mixes
	type checking and symbolic execution.  The key aspect of our
	approach is that these analyses are applied independently on
	disjoint parts of the program, in an off-the-shelf manner.  At
	the boundaries between nested type checked and symbolically
	executed code regions, we use special mix rules to communicate
	information between the off-the-shelf systems.  The resulting
	mixture is a provably sound analysis that is more precise than
	type checking alone and more efficient than exclusive symbolic
	execution.  In addition, we also describe a prototype
	implementation, <fmt kind="tool">Mixy</fmt>, for C.  Mixy
	checks for potential null dereferences by mixing a
	null/non-null type qualifier inference system with a symbolic
	executor.</p>
      </abstract>
    </pub>
    <pub id="profilers-pldi10">
      <title>Evaluating the Accuracy of Java Profilers</title>
      <authors>
	<author person="toddm" />
	<author person="diwan" />
	<author person="hauswirth" />
	<author person="sweeney" />
      </authors>
      <urls>
	<url name="pdf">papers/mytkowicz-pldi10.pdf</url>
      </urls>
      <howpub>
	<proceedings event="pldi10" />
      </howpub>
      <abstract>
	<p>
	  Performance analysts profile their programs to find methods
	  that are worth optimizing: the "hot" methods. This paper
	  shows that four commonly-used Java profilers (xprof, hprof,
	  jprofile, and yourkit) often disagree on the identity of the
	  hot methods. If two profilers disagree, at least one must be
	  incorrect. Thus, there is a good chance that a profiler will
	  mislead a performance analyst into wasting time optimizing a
	  cold method with little or no performance improvement.
	</p>
	<p>
	  This paper uses causality analysis to evaluate profilers and
	  to gain insight into the source of their incorrectness. It
	  shows that these profilers all violate a fundamental
	  requirement for sampling-based profilers: to be correct, a
	  sampling-based profiler must collect samples randomly.
	</p>
	<p>
	  We show that a proof-of-concept profiler, which collects
	  samples randomly, does not suffer from the above
	  problems. Specifically, we show, using a number of case
	  studies, that our profiler correctly identifies methods that
	  are important to optimize; in some cases other profilers
	  report that these methods are cold and thus not worth
	  optimizing.
	</p>
      </abstract>
    </pub>
    <pub id="threesomes-popl10">
      <title>Threesomes, With and Without Blame</title>
      <authors>
	<author person="siek" />
	<author person="wadler" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/popl10.pdf</url>
      </urls>
      <howpub>
	<proceedings event="popl10" />
      </howpub>
      <abstract>
	<p>The blame calculus of Wadler and Findler gives a high-level
	semantics to casts in higher-order languages. The coercion
	calculus of Henglein, on the other hand, provides an
	instruction set for casts whose normal forms ensure space
	efficiency. In this paper we address two questions: 1) can
	space efficiency be obtained in a high-level semantics? and 2)
	can we precisely characterize the relationship between the
	high and low-level semantics of casts? Towards answering both
	of these questions, we design a cast calculus that summarizes
	a sequence of casts as a threesome cast that contains a source
	type, a target type, and a third middle type that is the
	greatest lower bound of all the types in the sequence. We show
	that the threesome calculus is equivalent to the blame
	calculus and to one of the coercion-based, blame-tracking
	calculi of Siek, Garcia, and Taha. We also show that the
	threesome calculus is space efficient and obtain a tighter
	bound than that of Herman, Tomb, and Flanagan.</p>
      </abstract>
    </pub>
    <pub id="incremental-gpce10">
      <title>Incremental Type-Checking for Type-Reflective Metaprograms</title>
      <authors>
	<author person="miao" />
	<author person="siek" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/gpce10.pdf</url>
      </urls>
      <howpub>
	<proceedings event="gpce10" />
      </howpub>
      <abstract>
	<p></p>
      </abstract>
    </pub>
    <pub id="ssg-esop10">
      <title>Separating Shape Graphs</title>
      <authors>
	<author person="laviron" />
	<author person="bec" />
	<author person="rival" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/esop10-sepshapegraph.pdf</url>
      </urls>
      <howpub>
	  <proceedings event="esop10" />
      </howpub>
      <abstract>
	<p>Detailed memory models that expose individual fields are
	necessary to precisely analyze code that makes use of
	low-level aspects such as, pointers to fields and untagged
	unions.  Yet, higher-level representations that collect fields
	into records are often used because they are typically more
	convenient and efficient in modeling the program heap.  In
	this paper, we present a shape graph representation of memory
	that exposes individual fields while largely retaining the
	convenience of an object-level model.  This representation has
	a close connection to particular kinds of formulas in
	separation logic.  Then, with this representation, we show how
	to extend the <fmt kind="tool">Xisa</fmt> shape analyzer for
	low-level aspects, including pointers to fields, C-style
	nested structures and unions, malloc and free, and array
	values, with minimal changes to the core algorithms (e.g.,
	materialization and summarization).</p>
      </abstract>
    </pub>
    <pub id="invalidation-cgo10">
      <title>An efficient software transactional memory using commit-time invalidation</title>
      <authors>
	<author person="gottschlich" />
	<author person="vachharajani" />
	<author person="siek" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/cgo10.pdf</url>
      </urls>
      <howpub>
	<proceedings event="cgo10" />
      </howpub>
      <abstract>
	<p>To improve the performance of transactional memory (TM),
	researchers have found many eager and lazy optimizations for
	conflict detection, the process of determining if transactions
	can commit. Despite these optimizations, nearly all TMs
	perform one aspect of lazy conflict detection in the same
	manner to preserve serializability. That is, they perform
	commit-time validation, where a transaction is checked for
	conflicts with previously committed transactions during its
	commit phase. While commit-time validation is efficient for
	workloads that exhibit limited contention, it can limit
	transaction throughput for contending workloads.

        This paper presents an efficient implementation of commit-time
        invalidation, a strategy where transactions resolve their
        conflicts with in-flight (uncommitted) transactions before
        they commit. Commit-time invalidation supplies the contention
        manager (CM) with data that is unavailable through commit-time
        validation, allowing the CM to make decisions that increase
        transaction throughput. Commit-time invalidation also requires
        notably fewer operations than commit-time validation for
        memory-intensive transactions, uses zero commit-time
        operations for dynamically detected read-only transactions,
        and guarantees full opacity for any transaction in O(N) time,
        an improvement over incremental validation's O(N2) time. Our
        experimental results show that for contending workloads, our
        efficient commit-time invalidating software TM (STM) is up to
        3 x faster than TL2, a state-of-the-art validating STM.</p>
      </abstract>
    </pub>
    <pub id="gradprog-pldifit09">
      <title>Gradual Programming: Bridging the Semantic Gap (Position Paper)</title>
      <authors>
	<author person="bec" />
	<author person="diwan" />
	<author person="siek" />
      </authors>
      <urls>
	<url name="pdf">http://www.cs.colorado.edu/~bec/papers/pldifit09-gradprog.pdf</url>
      </urls>
      <howpub>
	<proceedings event="pldi-fit09" />
      </howpub>
    </pub>

    <pub id="bto-sc09">
      <title>Automating the Generation of Composed Linear Algebra Kernels</title>
      <authors>
	<author person="belter" />
	<author person="jessup" />
	<author person="karlin" />
	<author person="siek" />
      </authors>
      <urls>
	<url name="pdf">http://ecee.colorado.edu/~siek/sc09.pdf</url>
      </urls>
      <howpub>
	<proceedings event="sc09" />
      </howpub>
      <abstract>
	<p>Memory bandwidth limits the performance of important
	kernels in many scientific applications. Such applications
	often use sequences of Basic Linear Algebra Subprograms
	(BLAS), and highly efficient implementations of those routines
	enable scientists to achieve high performance at little
	cost. However, tuning the BLAS in isolation misses
	opportunities for memory optimization that result from
	composing multiple subprograms. Because it is not practical to
	create a library of all BLAS combinations, we have developed a
	domain-specific compiler that generates them on demand. In
	this paper, we describe a novel algorithm for compiling linear
	algebra kernels and searching for the best combination of
	optimization choices. We also present a new hybrid
	analytic/empirical method for quickly evaluating the
	profitability of each optimization. We report experimental
	results showing speedups of up to 130% relative to the
	GotoBLAS on an AMD Opteron and up to 137% relative to MKL on
	an Intel Core 2.</p>
      </abstract>
    </pub>
  </publications>

  <persons>
    <person id="bec" group="faculty">
      <name>Bor-Yuh Evan Chang</name>
      <url>http://www.cs.colorado.edu/~bec/</url>
      <face>pics/chang.jpg</face>
    </person>
    <person id="diwan" group="faculty">
      <name>Amer Diwan</name>
      <url>http://www.cs.colorado.edu/~diwan/</url>
      <face>pics/diwan.jpg</face>
    </person>
    <person id="grunwald" group="faculty">
      <name>Dirk Grunwald</name>
      <url>http://systems.cs.colorado.edu/people/faculty/dirk-grunwald/</url>
      <face>pics/grunwald.jpg</face>
    </person>
    <person id="srirams" group="faculty">
      <name>Sriram Sankaranarayanan</name>
      <url>http://www.cs.colorado.edu/~srirams/</url>
      <face>pics/sankaranarayanan.jpg</face>
    </person>
    <person id="siek" group="faculty">
      <name>Jeremy G. Siek</name>
      <url>http://ecee.colorado.edu/~siek/</url>
      <face>pics/siek.jpg</face>
    </person>
    <person id="fabio" group="faculty">
      <name>Fabio Somenzi</name>
      <url>http://vlsi.colorado.edu/~fabio/</url>
      <face>pics/somenzi.jpg</face>
    </person>
    <person id="vachharajani">
      <name>Manish Vachharajani</name>
      <url>http://ecee.colorado.edu/~manishv/</url>
      <face>pics/generic-male.jpg</face>
    </person>
    <person id="msridhar">
      <name>Manu Sridharan</name>
      <url>https://researcher.ibm.com/researcher/view.php?person=us-msridhar</url>
    </person>
    <person id="belter" group="phd">
      <name>Geoffrey Belter</name>
      <face>pics/generic-male.jpg</face>
    </person>
    <person id="blackshear" group="phd">
      <name>Sam Blackshear</name>
      <face>pics/blackshear.jpg</face>
    </person>
    <person id="blomstedt" group="phd">
      <name>Joseph Blomstedt</name>
      <face>pics/generic-male.jpg</face>
    </person>
    <person id="chakarov" group="phd">
     <name>Aleksandar Chakarov</name>
     <face>pics/chakarov.jpg</face>
    </person>
    <person id="coughlin" group="phd">
      <name>Devin Coughlin</name>
      <face>pics/coughlin.jpg</face>
    </person>
    <person id="cox" group="phd">
      <name>Arlen Cox</name>
      <url>http://eces.colorado.edu/~coxaj/</url>
      <face>pics/cox.jpg</face>
    </person>
    <person id="gottschlich">
      <name>Justin E. Gottschlich</name>
      <face>pics/generic-male.jpg</face>
    </person>
    <person id="jessup">
      <name>E.R. Jessup</name>
      <url>http://www.cs.colorado.edu/~jessup/</url>
    </person>
    <person id="karlin">
      <name>Ian Karlin</name>
      <face>pics/generic-male.jpg</face>
    </person>
    <person id="miao" group="phd">
      <name>Weiyu Miao</name>
      <face>pics/generic-male.jpg</face>
    </person>
    <person id="nelson" group="phd">
      <name>Thomas Nelson</name>
      <face>pics/generic-male.jpg</face>
    </person>
    <person id="tsai" group="phd">
      <name>Yi-Fan Tsai</name>
      <face>pics/tsai.jpg</face>
    </person>
    <person id="turner" group="phd">
      <name>Jonathan Turner</name>
      <face>pics/turner.jpg</face>
    </person>
    <person id="vitousek" group="phd">
      <name>Michael Vitousek</name>
      <face>pics/generic-male.jpg</face>
    </person>
    <person id="adityaz" group="phd">
      <name>Aditya Zutshi</name>
      <face> pics/zutshi.jpg </face>
    </person>
    <person id="bennett" group="ms">
      <name>Huck Bennett</name>
      <url>http://csel.cs.colorado.edu/~bennethd</url>  
      <face>pics/bennett.jpg</face>
    </person>
    <person id="bharadwaj" group="ms">
      <name>Shashank Bharadwaj</name>
      <face>pics/bharadwaj.jpg</face>
    </person>
    <person id="silkensen" group="ms">
      <name>Erik Silkensen</name>
      <url>http://csel.cs.colorado.edu/~silkense</url>
      <face>pics/silkensen.jpg</face>
    </person>
    <person id="frohardt">
      <name>Robert Frohardt</name>
      <url>http://www.cs.colorado.edu/~frohardt/</url>
    </person>
    <person id="creichen">
      <name>Christoph Reichenbach</name>
      <url>http://www.cs.umass.edu/~creichen/</url>
    </person>
    <person id="khooyp">
      <name>Khoo Yit Phang</name>
      <url>http://www.cs.umd.edu/~khooyp/</url>
    </person>
    <person id="jfoster">
      <name>Jeffrey S. Foster</name>
      <url>http://www.cs.umd.edu/~jfoster/</url>
    </person>
    <person id="laviron">
      <name>Vincent Laviron</name>
    </person>
    <person id="rival">
      <name>Xavier Rival</name>
      <url>http://www.di.ens.fr/~rival/</url>
    </person>
    <person id="atiwari">
      <name>Ashish Tiwari</name>
      <url>http://csl.sri.com/~tiwari/</url>
    </person>
    <person id="colonm">
      <name>Michael Colon</name>
    </person>
    <person id="fp">
      <name>Frank Pfenning</name>
      <url>http://www.cs.cmu.edu/~fp/</url>
    </person>
    <person id="astump">
      <name>Aaron Stump</name>
      <url>http://www.cs.uiowa.edu/~astump/</url>
    </person>
    <person id="cesar">
      <name>César Sánchez</name>
      <url>http://software.imdea.org/~cesar/</url>
    </person>
    <person id="swarat">
      <name>Swarat Chaudhuri</name>
      <url>http://www.cse.psu.edu/~swarat/</url>
    </person>
    <person id="putot">
      <name>Sylvie Putot</name>
      <url>http://www.lix.polytechnique.fr/Labo/Sylvie.Putot/</url>
    </person>
    <person id="goubault">
      <name>Eric Goubault</name>
      <url>http://www.lix.polytechnique.fr/~goubault/</url>
    </person>
    <person id="bycook">
      <name>Byron Cook</name>
      <url>http://research.microsoft.com/en-us/people/bycook/</url>
    </person>
    <person id="chaowang">
      <name>Chao Wang</name>
      <url>http://www.nec-labs.com/~chaowang/</url>
    </person>
    <person id="ivancic">
      <name>Franjo Ivančić</name>
      <url>http://www.nec-labs.com/~ivancic/</url>
    </person>
    <person id="burtscher">
      <name>Martin Burtscher</name>
      <url>http://www.cs.txstate.edu/~mb92/</url>
    </person>
    <person id="bradchen">
      <name>Brad Chen</name>
      <url>http://research.google.com/pubs/author37895.html</url>
    </person>
    <person id="bodik">
      <name>Rastislav Bodik</name>
      <url>http://www.cs.berkeley.edu/~bodik/</url>
    </person>
    <person id="bcpierce">
      <name>Benjamin C. Pierce</name>
      <url>http://www.cis.upenn.edu/~bcpierce/</url>
    </person>
    <person id="birkedal">
      <name>Lars Birkedal</name>
      <url>http://www.itu.dk/~birkedal/</url>
    </person>
    <person id="mstrout">
      <name>Michelle Mills Strout</name>
      <url>http://www.cs.colostate.edu/~mstrout/</url>
    </person>
    <person id="ssuryana">
      <name>Siddharth Suryanarayanan</name>
      <url>http://www.engr.colostate.edu/~ssuryana/</url>
    </person>
    <person id="fainekosg">
      <name>Georgios Fainekos</name>
      <url>http://www.public.asu.edu/~gfaineko/</url>
    </person>
    <person id="yeshwanta">
      <name>Yashwant Annapureddy</name>
    </person>
    <person id="liuche">
      <name>Che Liu</name>
    </person>
    <person id="amal">
      <name>Amal Ahmed</name>
      <url>https://www.cs.indiana.edu/~amal/</url>
    </person>
    <person id="robby">
      <name>Robert Bruce Findler</name>
      <url>http://www.eecs.northwestern.edu/~robby/</url>
    </person>
    <person id="wadler">
      <name>Philip Wadler</name>
      <url>http://homepages.inf.ed.ac.uk/wadler/</url>
    </person>
    <person id="toddm">
      <name>Todd Mytkowicz</name>
      <url>http://research.microsoft.com/en-us/people/toddm/</url>
    </person>
    <person id="sweeney">
      <name>Peter F. Sweeney</name>
      <url>https://researcher.ibm.com/researcher/view.php?person=us-pfs</url>
    </person>
    <person id="hauswirth">
      <name>Matthias Hauswirth</name>
      <url>http://www.inf.usi.ch/faculty/hauswirth/</url>
    </person>
  </persons>

  <events>
    <series id="popl">
      <name>Principles of Programming Languages</name>
      <longPrefix>ACM SIGACT-SIGPLAN Symposium on</longPrefix>
      <event id="popl11">
	<date>2011-01</date>
	<location>Austin, Texas, USA</location>
	<nth>Thirty-Eighth</nth>
	<url>http://www.cse.psu.edu/popl/11/</url>
      </event>
      <event id="popl10">
	<date>2010</date>
	<location>Madrid, Spain</location>
	<nth>Thirty-Seventh</nth>
	<url>http://www.cse.psu.edu/popl/10/</url>
      </event>
      <event id="popl08">
	<date>2008</date>
	<location>San Francisco, California, USA</location>
	<nth>Thirty-Fifth</nth>
	<url>http://www.cs.ucsd.edu/popl/08/</url>
      </event>
    </series>
    <series id="pldi">
      <name>Programming Language Design and Implementation</name>
      <longPrefix>ACM SIGPLAN Conference on</longPrefix>
      <event id="pldi10">
	<date>2010-06</date>
	<location>Toronto, Ontario, Canada</location>
	<url>http://www.cs.stanford.edu/pldi10/</url>
      </event>
      <event id="pldi09">
	<date>2009</date>
	<location>Dublin, Ireland</location>
	<url>http://www.cs.colorado.edu/pldi09/</url>
      </event>
    </series>
    <series id="cav">
      <name>Computer Aided Verification</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="cav11">
	<date>2011-07</date>
	<location>Snowbird, Utah, USA</location>
	<url>http://www.cs.utah.edu/events/conferences/cav2011/</url>
      </event>
    </series>
    <series id="esop">
      <name>European Symposium on Programming</name>
      <event id="esop11">
	<date>2011-03</date>
	<location> Saarbrücken, Germany </location>
        <url>http://www.etaps.org/etaps-2011/esop</url>
      </event>
      <event id="esop10"> 
	<date>2010-03</date>
	<location>Paphos, Cyprus</location>
	<nth>Nineteenth</nth>
	<url>http://research.microsoft.com/en-us/um/people/adg/esop2010/</url>
      </event>
    </series>
    <series id="tacas">
      <name>Tools and Algorithms for the Construction and Analysis of Systems</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="tacas11">
	<date>2011-03</date>
	<location> Saarbrücken, Germany </location>
	<url>http://www.etaps.org/etaps-2011/tacas</url>
      </event>
    </series>
    <series id="sas">
      <name>Static Analysis Symposium</name>
      <longPrefix>International</longPrefix>
      <event id="sas11">
	<date>2011-09</date>
	<location>Venice, Italy</location>
	<nth>Eighteenth</nth>
	<url>http://sas2011.cs.technion.ac.il/</url>
      </event>
      <event id="sas07">
	<date>2007</date>
	<nth>Fourteenth</nth>
	<url>http://www2.imm.dtu.dk/sas2007/</url>
      </event>
    </series>
    <series id="vmcai">
      <name>Verification, Model Checking, and Abstract Interpretation</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="vmcai11">
	<date>2011-01</date>
	<location>Austin, Texas, USA</location>
	<nth>Twelfth</nth>
	<url>http://vmcai11.cis.ksu.edu/</url>
      </event>
    </series>
    <series id="hscc">
      <name>Hybrid Systems: Computation and Control</name>
      <longPrefix>International Conference on</longPrefix>
      <event id="hscc11">
	<date>2011-04</date>
	<location>Chicago, Illinois, USA</location>
	<url>http://hscc2011.cs.sunysb.edu/</url>
      </event>
    </series>
    <series id="nsad">
      <name>Numerical and Symbolic Abstract Domains</name>
      <longPrefix>International Workshop on</longPrefix>
      <event id="nsad11">
	<date>2011</date>
	<nth>Third</nth>
	<url>http://software.imdea.org/events/nsad2011/</url>
      </event>
    </series>
    <series id="paste">
      <name>Program Analysis for Software Tools and Engineering</name>
      <longPrefix>ACM SIGPLAN-SIGSOFT Workshop on</longPrefix>
      <event id="paste11">
	<date>2011</date>
	<nth>Tenth</nth>
	<url>https://sites.google.com/site/paste2011/</url>
      </event>
    </series>
    <series id="pldi-fit">
      <name>Fun Ideas and Thoughts at PLDI</name>
      <event id="pldi-fit09">
	<date>2009</date>
	<url>http://www.cs.colorado.edu/pldi09/fit/</url>
	<location>Dublin, Ireland</location>
      </event>
    </series>
    <series id="fractal">
      <name>Front Range Architecture Compilers Tools and Languages Workshop</name>
      <event id="fractal-f09">
	<date>F2009</date>
	<url>http://fractal.cs.colorado.edu/</url>
	<location>Boulder, Colorado, USA</location>
      </event>
    </series>
    <series id="gpce">
      <name>Generative programming and component engineering</name>
      <event id="gpce10">
         <date>2010-10</date>
         <location>Eindhoven, The Netherlands</location>
         <nth>ninth</nth>
         <url>http://www.program-transformation.org/GPCE10/WebHome</url>
      </event>
    </series>
    <series id="sc">
     <name>International Conference on High Performance Computing Networking, Storage and Analysis</name>
     <event id="sc09">
       <location>Portland, Oregon, USA</location>
       <date>2009-11</date>
     </event>
    </series>
    <series id="cgo">
     <name>International Symposium on Code Generation and Optimization</name>
     <event id="cgo10">
       <location>Toronto, Canada</location>
       <date>2010-4</date>
     </event>
    </series>
  </events>
</cv>
